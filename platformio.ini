# This is the configuration file for PlatformIO, a cross-platform tool and IDE
# to build and develop software for embedded systems.
#
# To build the firmware with PlatformIO, install PlatformIO Core (CLI, no GUI):
# - https://docs.platformio.org/en/latest//core/installation.html
#
# For documentation on this file, see:
# - https://docs.platformio.org/en/latest/projectconf/index.html
#
# To add support for another STM32F1xx board, add a new [env:name..] section
# with the appropriate `board` and (optionally) `board_build.ldscript`.
# For a list of supported hardware, see:
# - https://docs.platformio.org/en/latest/platforms/ststm32.html
#
# To add support for additional grblHAL plugins or drivers, make the necessary
# changes to the common.build_flags, common.lib_deps and common.lib_extra_dirs
# below.
#
# By default this file sets the preprocessor directive `OVERRIDE_MY_MACHINE`
# to ignore all settings in `Inc/my_machine.h`.  Instead, you should edit this
# file and add the necessary directives (e.g. `-D FOOBAR_ENABLE`) to either
# `common.build_flags` or the environment specific `build_flags`.
#
# Typical command line usage:
#
#    # Build firmware for all defined environments
#    pio run
#    # Build only for specific environments with the -e option
#    pio run -e BTT_SKR_MINI_E3_V20 -e BTT_SKR_MINI_E3_V20_USB
#    # List the freshly built firmware ELF (.elf) and binary (.bin) files:
#    ls -l .pio/build/*/firmware.*
#    # If the target supports uploading (via `upload_protocol`):
#    pio run -e bluepill_f103c8_128k -t upload
#    # Clean up build related resources
#    pio run -t clean
#
[platformio]
include_dir = Inc
src_dir = Src

[common]
build_flags =
  -I .
  -I FatFS
  -I Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc
  -I Middlewares/ST/STM32_USB_Device_Library/Core/Inc
  -I USB_DEVICE/Target
  -D BOARD_FLEXI_HAL=1
  # Ignore all settings in Inc/my_machine.h (and instead use the below build flags)
  # -D OVERRIDE_MY_MACHINE
  # Uncomment to enable debug builds
  #-D DEBUG
  # Uncomment to enable support for keypad
  #-D KEYPAD_ENABLE=1
  # Uncomment to enable support for odometer
  #-D ODOMETER_ENABLE=1
  # Uncomment to enable support for running G-code from the microSD card
  # You also need to uncomment FatFS and sdcard in lib_deps (see below)
  #-D SDCARD_ENABLE=1
  # Set to 1 or 2 (see Inc/my_machine.h)
  #-D SPINDLE_HUANYANG=1
  -D VFD_ENABLE=-1
  -D MODBUS_ENABLE=1
  -D N_SPINDLE=8
  -D HSE_VALUE=25000000
  -D HAS_BOOTLOADER=1
  -D NGC_EXPRESSIONS_ENABLE=1
  -D ENABLE_BACKLASH_COMPENSATION=1
  -D MINIMIZE_PROBE_OVERSHOOT=1
  -D DEFAULT_PLANNER_BUFFER_BLOCKS=64
  -D INTERACTIVE_JOG_ENABLE=1
  -D MPG_ENABLE=1
  -D KEYPAD_ENABLE=1
  -D ESTOP_ENABLE=0
lib_deps =
  bluetooth
  grbl
  keypad
  laser
  motors
  odometer
# To enable support for SD card, you must grab a copy FatFS:
#   curl -O http://elm-chan.org/fsw/ff/arc/ff14b.zip
#   unzip ff14b.zip 'source/*'
#   mv source/* FatFS
#   rm -fr ff14b.zip source FatFS/diskio.c
# Next, apply the changes outlined in FatFS/README.md and then
# uncomment `FatFS` and `sdcard` below.
  #FatFS
  #sdcard
  spindle
  rgb
  # USB serial support
  Core
  Class
  App
  Target
lib_extra_dirs =
  .
  FatFS
  Middlewares/ST/STM32_USB_Device_Library
  USB_DEVICE

[env]
platform = ststm32
platform_packages = framework-stm32cubef4 @ ~1.26.2
framework = stm32cube
# Do not produce .a files for lib deps (which would prevent them from overriding weak symbols)
lib_archive = no
lib_ldf_mode = off
grblhal_driver_version = 20230129_090223.2
extra_scripts = 
    post:extra_script.py

[env:f446re_flexi_cnc_ygang]
board = genericSTM32F446RE
custom_prog_version = Y_GANGED
; change microcontroller
board_build.mcu = stm32f446ret6
board_build.ldscript = FLEXI_STM32F446RETX_BL_FLASH.ld
build_flags = ${common.build_flags}
  # See Inc/my_machine.h for options
  # -D N_AXIS=5
  -D Y_GANGED=1
  -D Y_AUTO_SQUARE=1
lib_deps = ${common.lib_deps}
  eeprom
lib_extra_dirs = ${common.lib_extra_dirs}
# Alternatively, place the .pio/build/<env name>/firmware.bin on the NODE_F4xxRE drive
upload_protocol = stlink

[env:f446re_flexi_cnc_ygang_rgb_door]
board = genericSTM32F446RE
custom_prog_version = YGANG_RGB_DOOR
; change microcontroller
board_build.mcu = stm32f446ret6
board_build.ldscript = FLEXI_STM32F446RETX_BL_FLASH.ld
build_flags = ${common.build_flags}
  # See Inc/my_machine.h for options
  # -D N_AXIS=5
  -D STATUS_LIGHT_ENABLE=1
  -D SAFETY_DOOR_ENABLE=1    
  -D Y_GANGED=1
  -D Y_AUTO_SQUARE=1
lib_deps = ${common.lib_deps}
  eeprom
lib_extra_dirs = ${common.lib_extra_dirs}
# Alternatively, place the .pio/build/<env name>/firmware.bin on the NODE_F4xxRE drive
upload_protocol = stlink

[env:f446re_flexi_cnc_3axis]
board = genericSTM32F446RE
custom_prog_version = 3_AXIS
; change microcontroller
board_build.mcu = stm32f446ret6
board_build.ldscript = FLEXI_STM32F446RETX_BL_FLASH.ld
build_flags = ${common.build_flags}
  # See Inc/my_machine.h for options
  # -D N_AXIS=5
  # -D Y_GANGED=1
  # -D Y_AUTO_SQUARE=1
lib_deps = ${common.lib_deps}
  eeprom
lib_extra_dirs = ${common.lib_extra_dirs}
# Alternatively, place the .pio/build/<env name>/firmware.bin on the NODE_F4xxRE drive
upload_protocol = stlink

[env:f446re_flexi_cnc_5axis]
board = genericSTM32F446RE
custom_prog_version = 5_AXIS
; change microcontroller
board_build.mcu = stm32f446ret6
board_build.ldscript = FLEXI_STM32F446RETX_BL_FLASH.ld
build_flags = ${common.build_flags}
  # See Inc/my_machine.h for options
  -D N_AXIS=5
  # -D Y_GANGED=1
  # -D Y_AUTO_SQUARE=1
lib_deps = ${common.lib_deps}
  eeprom
lib_extra_dirs = ${common.lib_extra_dirs}
# Alternatively, place the .pio/build/<env name>/firmware.bin on the NODE_F4xxRE drive
upload_protocol = stlink

[env:f446re_flexi_cnc_xgang_ygang]
board = genericSTM32F446RE
custom_prog_version = X_GANGED_Y_GANGED
; change microcontroller
board_build.mcu = stm32f446ret6
board_build.ldscript = FLEXI_STM32F446RETX_BL_FLASH.ld
build_flags = ${common.build_flags}
  # See Inc/my_machine.h for options
  # -D N_AXIS=5
  -D Y_GANGED=1
  -D Y_AUTO_SQUARE=1
  -D X_GANGED=1
  -D X_AUTO_SQUARE=1  
lib_deps = ${common.lib_deps}
  eeprom
lib_extra_dirs = ${common.lib_extra_dirs}
# Alternatively, place the .pio/build/<env name>/firmware.bin on the NODE_F4xxRE drive
upload_protocol = stlink